package frc.lib.pathing;

import frc.lib.motion.MotionProfile;
import frc.lib.motion.MotionState;
import frc.lib.motion.RobotConstraints;
import frc.lib.util.Util;
import frc.lib.util.Vec2;

public class PathFollower {
    private final double V_kv, V_ka, V_min;
    private final Waypoint[] waypoints;
    private final MotionProfile profile;
    public PathFollower(Vec2 start, double startAngle, Waypoint[] waypoints, double timestep,
         double V_kv, double V_ka, double V_min, double driveLength){

        this.V_kv = V_kv;
        this.V_ka = V_ka;
        this.V_min = V_min;
        this.waypoints = waypoints;

        // Find the optimal accMax and velMax        
        final double TOLERANCE = 1e-5;
        final double accMax = findOptimalAccMax(TOLERANCE);
        final double velMax = accMaxToVelMax(accMax);

        this.profile = new MotionProfile(MotionState.fromWheels(
            new RobotConstraints(velMax, accMax, driveLength), 
        0, start, startAngle, 0,0,0,0));
        MotionProfileGenerator.generate(profile, timestep, waypoints);
    }

    public double accMaxToVelMax(double accMax){
        return (12 - V_min - V_ka*accMax)/V_kv;
    }
    public double velMaxToAccMax(double velMax){
        return (12 - V_min - V_kv*velMax)/V_ka;
    }

    private double calculateProfileTime(double accMax){
        double velMax = accMaxToVelMax(accMax);
        RobotConstraints constraints = new RobotConstraints(velMax, accMax, 12);
        MotionProfile profile = MotionProfileGenerator.generate(constraints, 0.003, waypoints);
        return profile.dt();
    }

    private double findOptimalAccMax(double tol){
        final double invphi = (Math.sqrt(5) - 1) / 2; // 1/phi
        final double invphi2 = (3 - Math.sqrt(5)) / 2; // 1/phi^2

        double a = 0, b = velMaxToAccMax(0);
        double h = b - a;

        if(h <= tol) return (a+b)/2;

        // required steps to achieve tolerance
        final double n = (int)(Math.ceil(Math.log(tol/h)/Math.log(invphi)));

        double c = a + invphi2 * h;
        double d = a + invphi * h;
        double yc = calculateProfileTime(c);
        double yd = calculateProfileTime(d);

        for(int k = 0; k < n-1; k++){
            if (yc < yd) {
                b = d;
                d = c;
                yd = yc;
                h = invphi*h;
                c = a + invphi2 * h;
                yc = calculateProfileTime(c);
            } else {
                a = c;
                c = d;
                yc = yd;
                h = invphi*h;
                d = a + invphi * h;
                yd = calculateProfileTime(d);
            }
        }

        if (yc < yd) return (a+d)/2;
        else return (c+b)/2;
    }

    private void updateNonlinearFeedback(MotionState state) {
        // Implements eqn. 5.12 from https://www.dis.uniroma1.it/~labrob/pub/papers/Ramsete01.pdf
        final double kBeta = 2.0;  // >0.
        final double kZeta = 0.7;  // Damping coefficient, [0, 1].

        // Compute gain parameter.
        final double k = 2.0 * kZeta * Math.sqrt(kBeta*state.vel*state.vel + state.angVel*state.angVel);

        // Compute error components.
        final double angle_error_rads = mError.getRotation().getRadians();
        final double sin_x_over_x = Util.epsilonEquals(angle_error_rads, 0.0, 1E-2) ?
                1.0 : mError.getRotation().sin() / angle_error_rads;
        final double vel = state.vel * mError.getRotation().cos() + k * mError.getTranslation().x();
        
        final double angVel = state.angVel + k * angle_error_rads +
                        state.vel * kBeta * sin_x_over_x * mError.getTranslation().y();

        // Compute adjusted left and right wheel velocities.
        dynamics.wheel_velocity = mModel.solveInverseKinematics(adjusted_velocity);

        final double acc = mDt == 0 ? 0.0 : (dynamics.chassis_velocity.linear - prev_velocity_
                .linear) / mDt;
        dynamics.chassis_acceleration.angular = mDt == 0 ? 0.0 : (dynamics.chassis_velocity.angular - prev_velocity_
                .angular) / mDt;

        prev_velocity_ = dynamics.chassis_velocity;

        DriveSpecs.WheelState feedforward_voltages = mModel.solveInverseDynamics(dynamics.chassis_velocity,
                dynamics.chassis_acceleration).voltage;

        return new Output(dynamics.wheel_velocity.left, dynamics.wheel_velocity.right, dynamics.wheel_acceleration
                .left, dynamics.wheel_acceleration.right, feedforward_voltages.left, feedforward_voltages.right);
    }
}